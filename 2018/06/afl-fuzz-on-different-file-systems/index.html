<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>afl-fuzz on different file systems</title><meta name="description" content="Taking a look how afl-fuzz behaves on different file systems."/><link rel="stylesheet" href="/css/main.css"/><link rel="canonical" href="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/"/><link rel="alternate" type="application/rss+xml" title="Jussi Judin's weblog" href="https://feeds.feedburner.com/jussijudin"/><link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon-180x180.png"/><link rel="icon" type="image/png" href="/icons/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="/icons/android-chrome-192x192.png" sizes="192x192"/><link rel="icon" type="image/png" href="/icons/favicon-96x96.png" sizes="96x96"/><link rel="icon" type="image/png" href="/icons/favicon-16x16.png" sizes="16x16"/><link rel="manifest" href="/icons/manifest.json"/><link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#00a300"/><meta name="msapplication-TileImage" content="/icons/mstile-144x144.png"/><meta name="theme-color" content="#ffffff"/><meta content="928229747232422" property="fb:app_id"/><meta content="Jussi Judin's weblog" property="og:site_name"/><meta content="afl-fuzz on different file systems" property="og:title"/><meta content="article" property="og:type"/><meta content="Taking a look how afl-fuzz behaves on different file systems." property="og:description"/><meta content="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/" property="og:url"/><meta content="2018-06-10T18:00:10+03:00" property="article:published_time"/><meta content="https://barro.github.io/author/" property="article:author"/><meta property="og:image" content="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/id-cropped-800x400.png"/><meta content="fuzzing," property="article:tag"/><meta content="afl," property="article:tag"/><meta content="american" property="article:tag"/><meta content="fuzzy" property="article:tag"/><meta content="lop," property="article:tag"/><meta content="afl-fuzz," property="article:tag"/><meta content="libfuzzer" property="article:tag"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@b4rr0"/><meta name="twitter:creator" content="@b4rr0"/><meta name="twitter:title" content="afl-fuzz on different file systems"/><meta name="twitter:url" content="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/"/><meta name="twitter:description" content="Taking a look how afl-fuzz behaves on different file systems."/><meta name="twitter:image:src" content="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/id-square-400x400.png"/></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="/">Jussi Judin's weblog</a><nav class="site-nav"> <a href="#" class="menu-icon"> <svg viewBox="0 0 18 15"> <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/> <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/> <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/> </svg> </a><div class="trigger"> <a class="page-link" href="/archive/">Archive</a> <a class="page-link" href="/author/">Author</a> <a class="page-link" href="https://feeds.feedburner.com/jussijudin">RSS</a></div> </nav></div></header><div class="page-content"><div class="wrapper"><article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting"><meta itemprop="keywords" content="fuzzing,,afl,,american,fuzzy,lop,,afl-fuzz,,libfuzzer"/> <span itemprop="publisher" itemscope="itemscope" itemtype="https://schema.org/Organization"> <span itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://barro.github.io/icons/parruki-60x60.png"/><meta itemprop="width" content="60"/><meta itemprop="height" content="60"/> </span><meta itemprop="name" content="ParruKi blog"/> </span><meta itemprop="description" content="Taking a look how afl-fuzz behaves on different file systems."/><meta itemscope="itemscope" itemprop="mainEntityOfPage" itemType="https://schema.org/WebPage" itemid="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/"/> <header class="post-header"><h1 class="post-title" itemprop="name headline">afl-fuzz on different file systems</h1><p class="post-meta"><time datetime="2018-06-10T18:00:10+03:00" itemprop="datePublished dateModified">Sunday, Jun 10, 2018</time> • <span itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"> <span itemprop="name">Jussi Judin</span> </span> • <a itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" href="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/id-cropped-800x400.png"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAIAAACr2KkGAAAABnRSTlMAAAAAAABupgeRAAAASklEQVR4AWOAAxb1FjTEQAo48PwaBOGRyjR5DkGYauBSVHHQqINy2N8TRAxUAqMOojdApBgEIqRj1EFkJh1CUoTdQRBRw0GjDgIANbYlMjt0qBIAAAAASUVORK5CYII=" title="Article identicon" alt="Article identicon" width="48" height="12"/><meta itemprop="url" content="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/id-cropped-800x400.png"/><meta itemprop="width" content="800"/><meta itemprop="height" content="400"/> </a></p> </header><div class="post-content" itemprop="articleBody"><p>One day I was fuzzing around with <a href="http://lcamtuf.coredump.cx/afl/">american fuzzy lop</a> and accidentally pointed the output directory for fuzzer findings to point onto a file system on a physical disk instead of the usual shared memory file system. I noticed my mistake and changed the output directory to the usual place. Consequently there was a clear difference on how many fuzzing iterations/second <code class="highlighter-rouge">afl-fuzz</code> program could do. This then lead into this comparison of different file systems and fuzzing modes on them with the workload that <code class="highlighter-rouge">afl-fuzz</code> has.</p><h2 id="hardware-and-software-background">Hardware and software background</h2><p>Fuzzing is a computationally intensive way to find bugs in programs, usually fully exercising the machine CPU. This and writing data to the disk can have adverse effects on the hardware even if we are working with software. Some risks are listed in the common-sense risks section at <a href="http://lcamtuf.coredump.cx/afl/README.txt">american fuzzy lop’s README.txt</a> file that is a good read about the subject. In this article I’m mainly interested in what happens when you happen to point the output of <code class="highlighter-rouge">afl-fuzz</code> to a device with a specific file system.</p><h3 id="afl-fuzz-as-part-of-american-fuzzy-lop">afl-fuzz as part of american fuzzy lop</h3><p>American fuzzy lop is a successful generic purpose <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzer</a> that finds bugs for you while you sleep. <code class="highlighter-rouge">afl-fuzz</code> is the executable program that does the hard work of generating new data, repeatedly running the target program (fuzz target), and analyzing the results that come up in these fuzz target executions. It has handcrafted heuristics and fuzzing strategies that in practice provide quite successful results without the need for tuning.</p><div class="text-center"> <figure class="inline-figure" id="afl-fuzz-forkserver"><a href="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2900.png"> <picture><source type="image/webp" srcset="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-736.webp 736w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-920.webp 920w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-1104.webp 1104w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-1472.webp 1472w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2208.webp 2208w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2900.webp 2900w" sizes="736px, 920px, 1104px, 1472px, 2208px, 2900px"/> <source type="image/png" srcset="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-736.png 736w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-920.png 920w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-1104.png 1104w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-1472.png 1472w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2208.png 2208w,     https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2900.png 2900w" sizes="736px, 920px, 1104px, 1472px, 2208px, 2900px"/><img src="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/.png Interworkings of afl-fuzz, the fork server, and the fuzz target.""   alt="Interworkings of afl-fuzz, the fork server, and the fuzz target." width="736" height="355" class="figure-image" title="Interworkings of afl-fuzz, the fork server, and the fuzz target."/></picture> </a><figcaption class="text-center"> Figure 1: Interworkings of afl-fuzz, the fork server, and the fuzz target. </figcaption> </figure></div><p><a href="#afl-fuzz-forkserver">Figure 1</a> roughly visualizes the different parts that are part of a fuzzing session when using <code class="highlighter-rouge">afl-fuzz</code>. It spawns the program that we try to fuzz. This program then creates a <a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">fork server</a> that is responsible for communicating with the main <code class="highlighter-rouge">afl-fuzz</code> executable over <a href="http://man7.org/linux/man-pages/man2/pipe.2.html">pipes</a> and spawning new fuzz target instances with <a href="http://man7.org/linux/man-pages/man2/fork.2.html"><code class="highlighter-rouge">fork()</code></a> call. The fork server actually a small shim that is part of the fuzz target. Also the new program instance that <code class="highlighter-rouge">fork()</code> call spawns still technically holds a reference to the fork server, but those parts are just active at different times, visualized as gray in the figure. If the fuzz target is in <a href="https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html">persistent mode</a>, it doesn’t get restarted for every new input.</p><p>Data is passed to the fuzz target either over standard input or over a newly created file that the fuzz target reads. Then the fuzz target executes itself by writing an execution trace to a <a href="http://man7.org/linux/man-pages/man7/shm_overview.7.html">shared memory</a> and finishes running. <code class="highlighter-rouge">afl-fuzz</code> then reads the trace left by the fuzz target from the shared memory and creates a new input by mutating old ones. What to mutate is controlled by the new and historical information that the instrumentation data from the fuzz target provides.</p><h3 id="solid-state-drives">Solid state drives</h3><p><a href="https://en.wikipedia.org/wiki/Solid-state_drive">Solid state drives</a> are nowadays the most common physical storage medium in generic and special purpose computers. They are fast and relatively decently priced for the storage needs of a regular software developer. The decently priced solid state drives come with a price of somewhat limited write endurance due to the properties of the physical world and manufacturing compromises.</p><p>Currently (early 2018) the write endurance of a solid state drive promises to be around half in terabytes than what the drive capacity is in gigabytes on consumer level drives using (<a href="https://en.wikipedia.org/wiki/Multi-level_cell">TLC NAND</a>). This means that 200-250 gigabyte SSD has a write endurance around 100 terabytes. In practice, the write endurance will likely be more at least on <a href="https://techreport.com/review/27909/the-ssd-endurance-experiment-theyre-all-dead">a test from 2013-2015</a>.</p><p>Such write endurance does not really pose any limitations in the usual consumer level and professional workloads. But when it comes to fuzzing, it’s not the most usual workload. The whole idea of a fuzzer is to generate new data all the time, make the program execute it, and then either discard or save it depending of the program behavior is interesting or not. So we can expect that a fuzzer will generate quite a lot of data while it’s running.</p><p>Quick back-of-the-envelope calculation when assuming 10 parallel fuzzers running 1000 executions/second with 1000 byte input/execution on average would result in over 20 terabytes of data generated every month. If all this is directly written to a drive, then we can expect to have around 5 months until we reach the promised write endurance limits of a typical solid state drive at the time of this writing. There is caching that works to prolong this, but then there are all the invisible file system data structures, minimum file system block sizes, and <a href="https://en.wikipedia.org/wiki/Write_amplification">write amplification</a> then fight against these savings.</p><h3 id="two-data-passing-modes-of-afl-fuzz">Two data passing modes of afl-fuzz</h3><p><code class="highlighter-rouge">afl-fuzz</code> program has two ways to pass the new input to the fuzz target: passing the data over the standard input and creating a new file with the new data and having the fuzz target to read the data from the just created file file.</p><p>The most compact <code class="highlighter-rouge">afl-fuzz</code> command only includes the information for initial inputs, output directory and the command to execute the fuzz target without any special arguments:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>afl-fuzz <span class="nt">-i</span> <span class="k">in</span>/ <span class="nt">-o</span> out/ <span class="nt">--</span> fuzz-target
</code></pre></div></div><p>The fuzz target gets the input data from its standard input file descriptor so it does not need to explicitly open any files. Technically the standard input of the child process is backed by a file that is always modified by the <code class="highlighter-rouge">afl-fuzz</code> process when new input it generated. This file is also <code class="highlighter-rouge">.cur_input</code> file at the fuzzer instance directory. The exact details of how this works are explained later.</p><p>The more explicit input file path information including commands look like this:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># "@@" indicates the name of the file that the program gets with new</span>
<span class="c"># fuzz data. "-f" can be used to hard code the input file location</span>
<span class="c"># that then can be passed to the fuzz target or not.</span>
<span class="nv">$ </span>afl-fuzz <span class="nt">-i</span> <span class="k">in</span>/ <span class="nt">-o</span> out/ <span class="nt">--</span> fuzz-target @@
<span class="nv">$ </span>afl-fuzz <span class="nt">-i</span> <span class="k">in</span>/ <span class="nt">-o</span> out/ <span class="nt">-f</span> target.file <span class="nt">--</span> fuzz-target @@
<span class="nv">$ </span>afl-fuzz <span class="nt">-i</span> <span class="k">in</span>/ <span class="nt">-o</span> out/ <span class="nt">-f</span> target.file <span class="nt">--</span> fuzz-target
</code></pre></div></div><p>In the first command there is no explicit path to the input file specified, so the target program will get the path as the first argument, indicated by <code class="highlighter-rouge">@@</code>. The actual file is located at the fuzzer instance output directory (here it’s <code class="highlighter-rouge">out/</code>) as <code class="highlighter-rouge">.cur_input</code> file. Second two forms with <code class="highlighter-rouge">-f target.file</code> switch make it possible to define the location of the input file so that it can reside outside the output directory.</p><h4 id="details-of-input-data-writing">Details of input data writing</h4><p>Now that we know that <code class="highlighter-rouge">afl-fuzz</code> provides two different ways for the data to end in the program, then let’s look at the extracted details of <a href="https://github.com/mirrorer/afl/blob/2fb5a3482ec27b593c57258baae7089ebdc89043/afl-fuzz.c#L2468" title="afl 2.52b">write_to_testcase() function</a> to see how this data is passed to the child process.</p><p id="data-passing-stdin">When <code class="highlighter-rouge">afl-fuzz</code> writes data into the standard input stream of the fuzz target, the main parts of the code look like this in both <code class="highlighter-rouge">afl-fuzz</code> and fuzz target side:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// afl-fuzz part:
</span><span class="p">{</span>
    <span class="c1">// Make sure that reads done by fuzz target do not affect
</span>    <span class="c1">// new testcase writes:
</span>    <span class="n">lseek</span><span class="p">(</span><span class="n">testcase_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
    <span class="c1">// Write new testcase data to the file:
</span>    <span class="n">write</span><span class="p">(</span><span class="n">testcase_fd</span><span class="p">,</span> <span class="n">testcase_data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="c1">// Make sure that old data in testcase file does not leak
</span>    <span class="c1">// into the new fuzzing iteration:
</span>    <span class="n">ftruncate</span><span class="p">(</span><span class="n">testcase_fd</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="c1">// Make read() act as it would read a fresh standard input
</span>    <span class="c1">// instance:
</span>    <span class="n">lseek</span><span class="p">(</span><span class="n">testcase_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Fuzz target part:
</span><span class="p">{</span>
    <span class="c1">// stdin file descriptor inside fuzz target is actually
</span>    <span class="c1">// identical to testcase_fd thanks to dup2(). So we just
</span>    <span class="c1">// read whatever happens to be there:
</span>    <span class="kt">ssize_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">testcase_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="c1">// Do some actual fuzzing:
</span>    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>What happens in here that first the position in the file is changed to the beginning. A new data is written over the old one. The file length is changed to correspond to the new data length. The position is set to the beginning of the file again. Then the fuzz target reads from this file descriptor and runs the just written data through the actual program logic.</p><p id="data-passing-file">When passing data to the program through a named file following types of operations happen:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// afl-fuzz part:
</span><span class="p">{</span>
    <span class="c1">// Remove the old output file.
</span>    <span class="n">unlink</span><span class="p">(</span><span class="n">out_file</span><span class="p">);</span>
    <span class="c1">// Create a new file with the same name.
</span>    <span class="kt">int</span> <span class="n">out_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">abort</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// Write the test data into the created file.
</span>    <span class="n">write</span><span class="p">(</span><span class="n">out_fd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="c1">// Close the created file so that the data is available to other
</span>    <span class="c1">// processes.
</span>    <span class="n">close</span><span class="p">(</span><span class="n">out_fd</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Fuzz target part:
</span><span class="p">{</span>
    <span class="c1">// Open the file created by afl-fuzz.
</span>    <span class="kt">int</span> <span class="n">in_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">abort</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// Read enough data from the opened file descriptor for fuzzing.
</span>    <span class="kt">ssize_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">in_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="c1">// Close the opened file descriptor so that we don't leak
</span>    <span class="c1">// resources.
</span>    <span class="n">close</span><span class="p">(</span><span class="n">in_fd</span><span class="p">);</span>
    <span class="c1">// Do some actual fuzzing:
</span>    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>Basically old input file is removed and a new file is created, data is written to it and it’s closed. Then the fuzz target opens the just created file, reads the data out of it and closes the opened file descriptor closes it, and runs the data through the actual program logic.</p><p>You can already see that there are more file system related functions used when the fuzz data file is recreated. Then these functions are also more heavy than the ones used in the standard input version. When you call <a href="http://man7.org/linux/man-pages/man2/unlink.2.html"><code class="highlighter-rouge">unlink()</code></a> and <a href="http://man7.org/linux/man-pages/man2/open.2.html"><code class="highlighter-rouge">open()</code></a>, Linux kernel needs to do <a href="https://github.com/torvalds/linux/blob/03f51d4efa2287cc628bb20b0c032036d2a9e66a/Documentation/filesystems/path-lookup.md">pathname lookup</a> to figure out what exact file objects are accessed. When you only have the file descriptor to manipulate in the standard input case, you avoid these pathname lookups and hopefully manipulate purely numeric data. Also when you open a new file, it has to actually create the corresponding <a href="https://en.wikipedia.org/wiki/Inode">inodes</a> and their data structures to the file system. This has a certain amount of overhead.</p><p>So looking at the called functions, it would feel like there is going to be a fuzzing overhead difference between these two input data creation approaches.</p><h2 id="benchmarking">Benchmarking</h2><p>Theoretical speculation is always nice, but the real hard data comes from the benchmarking. This section looks at the fuzzing overhead from both <code class="highlighter-rouge">afl-fuzz</code> perspective with low and high level filesystem access functions and from raw file system access perspective. Also the <a href="#data-writes">section about data writes</a> tries to find an answer to the question that how damaging fuzzing can actually be to a solid state drive with a relatively limited write endurance.</p><p>I did these benchmarks with several major general purpose file systems found from <a href="https://www.debian.org/">Debian</a> provided Linux kernels 4.14.13-1 and 4.15.11-1. These can show up as differences in numbers between tables, but numbers inside the same table are done with the same system. Also there is small variance between fuzzing sessions that I have tried to eliminate running the fuzzers for long enough that system maintenance and other short running tasks don’t have too big of an impact. But the relative mileage may vary between kernel versions, operating system libraries, and between the actual physical machines.</p><h3 id="executionssecond">Executions/second</h3><p>General purpose instrumentation guided fuzzers like american fuzzy lop and <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a> get their power from the fact that they can repeatedly execute the fuzz target in quick succession. Speed is one factor, but also the program stability from one execution to another is a second one. Having stable program ensures that the issues that fuzzing finds can be easily replicated. This basically leads into a compromise of selecting the appropriate fuzzer and fuzz target execution strategy.</p><p>It can be that the program has a global state that needs program restart or other tricks between runs. For these types of situations the default forkserver mode in <code class="highlighter-rouge">afl-fuzz</code> is appropriate. On the other hand if everything can be functionally wrapped inside a function that does not leak its state outside, we can use the much faster persistent mode in <code class="highlighter-rouge">afl-fuzz</code>. From this it should be actually quite easy to port the fuzz target to libFuzzer.</p><p>In this case libFuzzer shows 735 k executions/second with the <a href="#the-example-fuzz-target">sample target</a> when the data is not passed between process boundaries. It is also possible to simulate in-memory file streams with <a href="http://man7.org/linux/man-pages/man3/fmemopen.3.html"><code class="highlighter-rouge">fmemopen()</code></a> function where libFuzzer achieved with this example program 550 k executions/second. This is 15-20 times lower fuzzing overhead than with <code class="highlighter-rouge">afl-fuzz</code>. But in this article we focus on american fuzzy lop’s persistent mode and leave the fuzzing engine selection for some other time.</p><p>A typical american fuzzy lop’s persistent mode fuzz target would generally have some generic configuration in the beginning and then the actual data dependent program execution would reside inside a <code class="highlighter-rouge">while (__AFL_LOOP(40000)) { ... }</code> loop. The number 40000 is just the number of iterations that the program does before it restarts again and can be lower or higher depending on how confident you are that the program does not badly misbehave.</p><p>Using the standard input with the persistent mode makes the data reading code look like following:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">generic_configuration</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">input_fd</span> <span class="o">=</span> <span class="n">fileno</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">40000</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">ssize_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">input_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">abort</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// Do the actual fuzzing.
</span>    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>Using named files with the persistent mode on the other hand requires opening a new file every iteration:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">generic_configuration</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">40000</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">input_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">input_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">abort</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">input_fd</span><span class="p">);</span>
    <span class="c1">// Do the actual fuzzing.
</span>    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h4 id="the-example-fuzz-target">The example fuzz target</h4><p>I directly used the code from my <a href="/2018/01/taking-a-look-at-python-afl/">Taking a look at python-afl</a> article and modified it to support the file and stdin reader variants. This code is available from <a href="target-simple.cpp">target-simple.cpp</a> for the prying eyes. Also the later on introduced C and C++ standard library variants are available as <a href="target-fread.cpp">target-fread.cpp</a> and <a href="target-ifstream.cpp">target-ifstream.cpp</a>.</p><h4 id="file-system-dependent-results">File system dependent results</h4><p>The benchmarking was done with a <a href="https://linux.die.net/man/8/losetup">loopback device</a> that fully resides in memory. Each of these file systems was created and mounted with their default options and the performance test was run for 2 minutes. Only a single instance of <code class="highlighter-rouge">afl-fuzz</code> was running. You can see from the <a href="#execs-per-second">table 1</a> the difference between the same workload on different file systems. The <a href="https://www.kernel.org/doc/gorman/html/understand/understand015.html">shared memory virtual file system</a> (tmpfs) was the most efficient in both of these cases.</p><div class="text-center"> <figure class="inline-figure" id="execs-per-second"><table style="margin:0 auto"><thead><tr><th style="text-align:left">execs/second</th><th style="text-align:right"><a href="#data-passing-stdin">stdin</a></th><th style="text-align:right"><a href="#data-passing-file">file</a></th></tr></thead><tbody><tr><td style="text-align:left">btrfs</td><td style="text-align:right">20.5 k</td><td style="text-align:right">14.6 k</td></tr><tr><td style="text-align:left">ext2</td><td style="text-align:right">31.6 k</td><td style="text-align:right">19.2 k</td></tr><tr><td style="text-align:left">ext3</td><td style="text-align:right">30.0 k</td><td style="text-align:right">18.4 k</td></tr><tr><td style="text-align:left">ext4</td><td style="text-align:right">28.0 k</td><td style="text-align:right">18.2 k</td></tr><tr><td style="text-align:left">JFS</td><td style="text-align:right">31.7 k</td><td style="text-align:right">17.1 k</td></tr><tr><td style="text-align:left">ReiserFS</td><td style="text-align:right">28.0 k</td><td style="text-align:right">14.5 k</td></tr><tr><td style="text-align:left">tmpfs</td><td style="text-align:right"><strong>34.6 k</strong></td><td style="text-align:right"><strong>25.5 k</strong></td></tr><tr><td style="text-align:left">XFS</td><td style="text-align:right">21.1 k</td><td style="text-align:right">16.8 k</td></tr></tbody></table><figcaption class="text-center">Table 1: Average number of fuzz target executions/second over 2 minute measuring period with different file systems.</figcaption> </figure></div><p>This result also shows an interesting history between ext2, ext3, and ext4 file systems. Their performance seems to decrease the newer the file system is, likely due to larger amount of data safety operations that the newer file systems do. There could be difference when parallel access to a file system is concerned.</p><h3 id="execution-speed-with-different-standard-libraries">Execution speed with different standard libraries</h3><p>I also wanted to see how the use of more portable file system calls in both C and C++ standard libraries affects the fuzzing speed. Standard libraries like <a href="https://www.gnu.org/software/libc/">glibc</a>, <a href="https://gcc.gnu.org/onlinedocs/libstdc++/">libstdc++</a>, and <a href="https://libcxx.llvm.org/">libc++</a> provide a portable file system interface across operating systems. They also provide a certain amount of buffering so that every small read does not result in a system call and suffer from context switch overhead. These higher level library functions also aim to be thread safe so that concurrent manipulation of the same file descriptor would be a little bit less surprising.</p><p>When doing fuzzing, we are usually just reading small amount of data once and then either close the input file or expect the <code class="highlighter-rouge">afl-fuzz</code> to <a href="#data-passing-stdin">reset the input stream for us</a>. Any buffering information must also be discarded and the stream position must be reset so that the input data for the fuzz target is the same what <code class="highlighter-rouge">afl-fuzz</code> expects it to be. If it’s not, it will show as a lower than 100 % stability value on <a href="http://lcamtuf.coredump.cx/afl/status_screen.txt">AFL status screen</a>.</p><p>Following is the C code used to benchmark how much overhead the standard C library functions bring into this. Standard input is put into unbuffered mode with <a href="http://man7.org/linux/man-pages/man3/setvbuf.3p.html"><code class="highlighter-rouge">setvbuf()</code></a> function call, so buffer manipulation should not have a meaningful amount of overhead.</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C version for glibc benchmarking with standard file manipulation functions.
</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="n">input_fd</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">;</span>
<span class="n">setvbuf</span><span class="p">(</span><span class="n">input_fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">40000</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">input_fd</span><span class="p">);</span>
    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// We get the fuzz data filename from argv[1].
</span><span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">40000</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">input_fd</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"rb"</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">input_fd</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">input_fd</span><span class="p">);</span>
    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>C++ streams don’t have a working unbuffered reads that would behave reliably. The closest equivalent to this is to call <a href="http://en.cppreference.com/w/cpp/io/basic_istream/seekg"><code class="highlighter-rouge">istream::seekg()</code></a> and after that <a href="http://en.cppreference.com/w/cpp/io/basic_ios/clear"><code class="highlighter-rouge">istream::clear()</code></a> function. This basically is theoretically equivalent to what <a href="http://man7.org/linux/man-pages/man3/rewind.3p.html"><code class="highlighter-rouge">rewind()</code></a> function does. Other solution of trying to set <a href="http://en.cppreference.com/w/cpp/io/basic_ios/rdbuf"><code class="highlighter-rouge">istream::rdbuf()</code></a> to a zero sized one had no real effect on increasing stability.</p><p>C++ code for these fuzzing benchmarks looks like following:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++ version for libstdc++ and libc++ benchmarking with the standard
// C++11 file manipulation functions.
</span>
<span class="k">auto</span> <span class="n">input_fd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">40000</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Resetting stream state is 2 function calls.
</span>    <span class="n">input_fd</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">input_fd</span><span class="p">.</span><span class="n">beg</span><span class="p">);</span>
    <span class="n">input_fd</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">input_fd</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kt">size_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">input_fd</span><span class="p">.</span><span class="n">gcount</span><span class="p">();</span>
    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// We get the fuzz data filename from argv[1].
</span><span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">40000</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">input_fd</span><span class="p">(</span>
        <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">in</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="n">input_fd</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="kt">size_t</span> <span class="n">read_size</span> <span class="o">=</span> <span class="n">input_fd</span><span class="p">.</span><span class="n">gcount</span><span class="p">();</span>
    <span class="n">input_fd</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="n">fuzz_one</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">read_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>C++ code is a little bit more verbose than C code, as there are extra layers of abstraction that need to be removed so that <code class="highlighter-rouge">afl-fuzz</code> style data processing is possible. <a href="#libs-execs-per-second">Table 2</a> then shows what is the speed difference of these different implementations and standard libraries.</p><div class="text-center"> <figure class="inline-figure" id="libs-execs-per-second"><table style="margin:0 auto"><thead><tr><th style="text-align:left">execs/second</th><th style="text-align:right">syscalls</th><th style="text-align:right">glibc</th><th style="text-align:right">libstdc++</th><th style="text-align:right">libc++</th></tr></thead><tbody><tr><td style="text-align:left"><a href="#data-passing-stdin">stdin</a></td><td style="text-align:right">33.5 k</td><td style="text-align:right">32.4 k (98 %)</td><td style="text-align:right">31.2 k (93 %)</td><td style="text-align:right">30.7 k (92 %)*</td></tr><tr><td style="text-align:left"><a href="#data-passing-file">file</a></td><td style="text-align:right">24.2 k</td><td style="text-align:right">22.8 k (94 %)</td><td style="text-align:right">22.0 k (91 %)</td><td style="text-align:right">20.7 k (86 %)</td></tr></tbody></table><figcaption class="text-center">Table 2: Fuzz target executions/second over 2 minute period with different standard libraries on tmpfs.<div>* The stability of libc++ stdin session was not 100 %.</div></figcaption> </figure></div><p>We can see that the pure combination of <code class="highlighter-rouge">open()</code> and <code class="highlighter-rouge">read()</code> functions is the fastest one. Portable C standard library implementation comes quite close with the unbuffered standard input implementation, but everywhere else there is a clear performance loss.</p><p>Stability is an important measurement of how reliably fuzzing can continue. Unfortunately in this tests everything was not 100 % stable. The standard input reading and resetting for libc++ does not fully work as expected and leads into reading old data.</p><p>The conclusion here is that try to stay with the low level unbuffered file manipulation functions or as close to their equivalents. More portable higher level functions for file access may provide speed benefits through buffering for regular file access patterns, but in this case they just add extra layers that slow down the data passing from <code class="highlighter-rouge">afl-fuzz</code> to the fuzz target. Unless the fuzz target itself relies on using those higher level functions.</p><h3 id="data-writes">Data writes</h3><p>In the <a href="#hardware-and-software-background">background section</a> I described how it generally is a bad idea to write data to a physical disk, as modern solid state drives have a limited write durability. But one could think that the write caching done by Linux would prevent a situation from happening where data is constantly written to the disk if the lifetime of a file contents is really short.</p><p>The write caching towards block devices is handled by the <a href="https://en.wikipedia.org/wiki/Page_cache">page cache</a> in the kernel. But as different file systems may write every new file or file part into a new location, this cache is not necessarily as effective as it could be. Even if the writes happen to the same file with very little data.</p><p>In this section I let <code class="highlighter-rouge">afl-fuzz</code> to run for 30 minutes and looked at the kilobytes written by <a href="http://man7.org/linux/man-pages/man1/iostat.1.html"><code class="highlighter-rouge">iostat</code></a> to a block device that was a file in memory that was mounted on a <a href="https://linux.die.net/man/8/losetup">loopback device</a>. This way the device should have looked like a real block device without the risk of shortening the lifespan of any real hardware. Estimated monthly values for disk writes for various file systems can be seen from <a href="#data-writes-month-single">table 3</a> for a single <code class="highlighter-rouge">afl-fuzz</code> instance.</p><div class="text-center"> <figure class="inline-figure" id="data-writes-month-single"><table style="margin:0 auto"><thead><tr><th style="text-align:left">writes/month</th><th style="text-align:right"><a href="#data-passing-stdin">stdin</a></th><th style="text-align:right"><a href="#data-passing-file">file</a></th></tr></thead><tbody><tr><td style="text-align:left">btrfs</td><td style="text-align:right"><strong>3.052 TiB</strong></td><td style="text-align:right">0.020 TiB</td></tr><tr><td style="text-align:left">ext2</td><td style="text-align:right">0.004 TiB</td><td style="text-align:right">0.005 TiB</td></tr><tr><td style="text-align:left">ext3</td><td style="text-align:right">0.020 TiB</td><td style="text-align:right">0.028 TiB</td></tr><tr><td style="text-align:left">ext4</td><td style="text-align:right">0.035 TiB</td><td style="text-align:right">0.021 TiB</td></tr><tr><td style="text-align:left">JFS</td><td style="text-align:right"><strong>9.74 TiB</strong></td><td style="text-align:right"><strong>69.8 TiB</strong></td></tr><tr><td style="text-align:left">ReiserFS</td><td style="text-align:right">0.021 TiB</td><td style="text-align:right">0.024 TiB</td></tr><tr><td style="text-align:left">tmpfs</td><td style="text-align:right">-</td><td style="text-align:right">-</td></tr><tr><td style="text-align:left">XFS</td><td style="text-align:right"><strong>201 TiB</strong></td><td style="text-align:right">0.004 TiB</td></tr></tbody></table><figcaption class="text-center">Table 3: Estimated monthly data writes for a single fuzzer on different file systems.</figcaption> </figure></div><p>The numbers for the amount of data that would be written to the device is an extrapolation of the 30 minute run and show values are in terabytes (2<sup>40</sup> bytes). These numbers are for the persistent mode and for an extremely light algorithm. They still give some estimate on the amount of data writes to the disk even for algorithms that are 10-100 times slower. Nowadays a typical desktop computer can easily have 8-16 threads and the order of typically processed data per fuzzer iteration is closer to 1 kilobyte than to 128 bytes as in this case.</p><p>When looking at these numbers, btrfs, JFS, and XFS file systems are pretty dangerous ones to accidentally use, as the faster stdin mode where data is fed to always open file handle actually causes a meaningful amount of data to be written to a disk per month. Especially with XFS it’s 4 kilobytes of data written/fuzzing iteration. Taking into account that many solid state disk drives have write endurance only in hundreds of terabytes, accidentally running even one fuzzer for one month or more makes a significant dent in its lifetime for these file systems.</p><p>I also wanted to see what happens when you run multiple fuzzers in parallel on the same machine. The most trivial assumption for multiple fuzzers would be that the file system writes would increase about linearly with the number of fuzzers. The results on <a href="#data-writes-month-x4">table 4</a> show that this is indeed the case for most of the file systems, except for ext2. Fortunately ext2 is not the worst data writer of the measured file systems and you really need to go extra mile to use it nowadays, as newer ext3 and ext4 file systems have replaced it by default.</p><div class="text-center"> <figure class="inline-figure" id="data-writes-month-x4"><table style="margin:0 auto"><thead><tr><th style="text-align:left">writes/month</th><th style="text-align:right"><a href="#data-passing-stdin">stdin</a> x4</th><th style="text-align:right"><a href="#data-passing-file">file</a> x4</th></tr></thead><tbody><tr><td style="text-align:left">btrfs</td><td style="text-align:right"><strong>9.53 TiB</strong> (78 %)</td><td style="text-align:right">0.052 TiB (65 %)</td></tr><tr><td style="text-align:left">ext2</td><td style="text-align:right">0.072 TiB (<strong>450 %</strong>)</td><td style="text-align:right">0.120 TiB (<strong>600 %</strong>)</td></tr><tr><td style="text-align:left">ext3</td><td style="text-align:right">0.075 TiB (94 %)</td><td style="text-align:right">0.147 TiB (130 %)</td></tr><tr><td style="text-align:left">ext4</td><td style="text-align:right">0.090 TiB (64 %)</td><td style="text-align:right">0.088 TiB (100 %)</td></tr><tr><td style="text-align:left">JFS</td><td style="text-align:right"><strong>44.4 TiB</strong> (110 %)</td><td style="text-align:right"><strong>339 TiB</strong> (120 %)</td></tr><tr><td style="text-align:left">ReiserFS</td><td style="text-align:right">0.069 TiB (82 %)</td><td style="text-align:right">0.072 TiB (75 %)</td></tr><tr><td style="text-align:left">tmpfs</td><td style="text-align:right">-</td><td style="text-align:right">-</td></tr><tr><td style="text-align:left">XFS</td><td style="text-align:right"><strong>786 TiB</strong> (98 %)</td><td style="text-align:right">0.035 TiB (220 %)</td></tr></tbody></table><figcaption class="text-center">Table 4: Monthly data writes for a 4 parallel fuzzers on different file systems and the percentage to an extrapolated number based on one afl-fuzz instance.</figcaption> </figure></div><p>The worrying part here is that two quite actively and widely used file systems, btrfs and XFS, suffer greatly from the writes with the standard input data generation pattern. As this is the faster mode of fuzzing from executions/second perspective, it’s quite nasty if you put the output directory for fuzzer findings on such file system.</p><h3 id="theoretical-limits">Theoretical limits</h3><p>I also wanted to see what would be the theoretical limits for the type of file system access pattern that <code class="highlighter-rouge">afl-fuzz</code> does. This is quite a synthetic benchmark, as it does not involve any context switches between processes, <a href="http://man7.org/linux/man-pages/man7/signal.7.html">signal</a> delivery, <a href="http://man7.org/linux/man-pages/man7/shm_overview.7.html">shared memory</a> manipulation, <a href="http://man7.org/linux/man-pages/man2/dup.2.html">file descriptor duplication</a>, and other types of data processing that <code class="highlighter-rouge">afl-fuzz</code> does.</p><div class="text-center"> <figure class="inline-figure" id="theoretical-fs-benchmark"><table style="margin:0 auto"><thead><tr><th style="text-align:left">sequences/second</th><th style="text-align:right"><a href="#data-passing-stdin">stdin</a></th><th style="text-align:right"><a href="#data-passing-file">file</a></th></tr></thead><tbody><tr><td style="text-align:left">btrfs</td><td style="text-align:right">87.5 k</td><td style="text-align:right">40.7 k</td></tr><tr><td style="text-align:left">ext2</td><td style="text-align:right">446.1 k</td><td style="text-align:right">66.5 k</td></tr><tr><td style="text-align:left">ext3</td><td style="text-align:right">305.4 k</td><td style="text-align:right">60.3 k</td></tr><tr><td style="text-align:left">ext4</td><td style="text-align:right">211.5 k</td><td style="text-align:right">56.4 k</td></tr><tr><td style="text-align:left">JFS</td><td style="text-align:right"><strong>737.7 k</strong></td><td style="text-align:right">59.5 k</td></tr><tr><td style="text-align:left">ReiserFS</td><td style="text-align:right">594.1 k</td><td style="text-align:right">40.4 k</td></tr><tr><td style="text-align:left">tmpfs</td><td style="text-align:right">682.5 k</td><td style="text-align:right"><strong>138.0 k</strong></td></tr><tr><td style="text-align:left">XFS</td><td style="text-align:right">101.9 k</td><td style="text-align:right">48.5 k</td></tr></tbody></table><figcaption class="text-center">Table 5: Theoretical file system performance numbers with `afl-fuzz` like access pattern.</figcaption> </figure></div><p>The difference between file systems in <a href="#theoretical-fs-benchmark">table 5</a> is many times larger for standard input based data generation than for <code class="highlighter-rouge">afl-fuzz</code> (<a href="#execs-per-second">table 1</a>). When opening and closing files, the overhead is bigger and the difference between different file systems is also smaller.</p><p>If you also compare the overhead of pure file system accesses, it is higher than the overhead of <a href="#executionssecond">libFuzzer’s 735 k executions/second</a> basically for all cases. On top of this there is the overhead of everything else that happens inside <code class="highlighter-rouge">afl-fuzz</code> program.</p><h2 id="end-notes">End notes</h2><p>You should use tmpfs that fully resides in memory for your fuzzing data generation with <code class="highlighter-rouge">afl-fuzz</code>. Usually this is available on <code class="highlighter-rouge">/dev/shm/</code> or <code class="highlighter-rouge">/run/shm/</code> globally and on systemd based systems also available under <code class="highlighter-rouge">/run/user/$UID/</code>. It’s faster and less straining to the hardware than trusting that the Linux block layer does not too often write to the physical device. Especially if you happen to use btrfs or XFS file systems.</p><p>In the end, this is mostly Linux specific information and for example OS X based systems need <a href="https://gist.github.com/koshigoe/822455">specific tricks</a> to use memory based file systems. Same with FreeBSD where tmpfs based file system is not mounted by default.</p></div></article><div id="disqus_thread"></div> <script>var disqus_config=function(){this.page.url="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/",this.page.identifier="/2018/06/afl-fuzz-on-different-file-systems"};!function(){var e=document,t=e.createElement("script");t.src="//barro.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)}()</script></div></div><footer class="site-footer"><div class="wrapper"><h2 class="footer-heading">Jussi Judin's weblog</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li>Jussi Judin</li><li>jju<span>din</span>+github <span>AT</span> iki DOT <span>f</span>i</li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li> <a href="https://github.com/barro" title="Barro">GitHub</a></li><li> <a href="https://bitbucket.org/barro" title="barro">Bitbucket</a></li><li> <a href="https://facebook.com/b4rr0" title="B4rr0">Facebook</a></li><li> <a href="https://twitter.com/B4rr0" title="@B4rr0">Twitter</a></li><li> <a href="https://plus.google.com/+JussiJudin-jj/" title="+JussiJudin-jj">Google+</a></li></ul></div><div class="footer-col footer-col-3"><p>Programming related topics. Maybe even some original content!</p></div></div></div></footer><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-71880517-1","auto"),ga("send","pageview")</script></body></html>