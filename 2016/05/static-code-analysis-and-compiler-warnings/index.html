<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Static code analysis and compiler warnings</title><meta name="description" content="Examining the the cost and place of compiler warnings as a static code analysis technique."/><link rel="stylesheet" href="/css/main.css"/><link rel="canonical" href="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/"/><link rel="alternate" type="application/rss+xml" title="Jussi Judin's weblog" href="https://feeds.feedburner.com/jussijudin"/><link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon-180x180.png"/><link rel="icon" type="image/png" href="/icons/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="/icons/android-chrome-192x192.png" sizes="192x192"/><link rel="icon" type="image/png" href="/icons/favicon-96x96.png" sizes="96x96"/><link rel="icon" type="image/png" href="/icons/favicon-16x16.png" sizes="16x16"/><link rel="manifest" href="/icons/manifest.json"/><link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#00a300"/><meta name="msapplication-TileImage" content="/icons/mstile-144x144.png"/><meta name="theme-color" content="#ffffff"/><meta content="928229747232422" property="fb:app_id"/><meta content="Jussi Judin's weblog" property="og:site_name"/><meta content="Static code analysis and compiler warnings" property="og:title"/><meta content="article" property="og:type"/><meta content="Examining the the cost and place of compiler warnings as a static code analysis technique." property="og:description"/><meta content="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/" property="og:url"/><meta content="2016-05-08T19:00:06+03:00" property="article:published_time"/><meta content="https://barro.github.io/author/" property="article:author"/><meta property="og:image" content="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/id-cropped-800x400.png"/><meta content="c/c++" property="article:tag"/><meta content="static-analysis" property="article:tag"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@b4rr0"/><meta name="twitter:creator" content="@b4rr0"/><meta name="twitter:title" content="Static code analysis and compiler warnings"/><meta name="twitter:url" content="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/"/><meta name="twitter:description" content="Examining the the cost and place of compiler warnings as a static code analysis technique."/><meta name="twitter:image:src" content="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/id-square-400x400.png"/></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="/">Jussi Judin's weblog</a><nav class="site-nav"> <a href="#" class="menu-icon"> <svg viewBox="0 0 18 15"> <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/> <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/> <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/> </svg> </a><div class="trigger"> <a class="page-link" href="/archive/">Archive</a> <a class="page-link" href="/author/">Author</a> <a class="page-link" href="https://feeds.feedburner.com/jussijudin">RSS</a></div> </nav></div></header><div class="page-content"><div class="wrapper"><article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting"><meta itemprop="keywords" content="c/c++,static-analysis"/> <span itemprop="publisher" itemscope="itemscope" itemtype="https://schema.org/Organization"> <span itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://barro.github.io/icons/parruki-60x60.png"/><meta itemprop="width" content="60"/><meta itemprop="height" content="60"/> </span><meta itemprop="name" content="ParruKi blog"/> </span><meta itemprop="description" content="Examining the the cost and place of compiler warnings as a static code analysis technique."/><meta itemscope="itemscope" itemprop="mainEntityOfPage" itemType="https://schema.org/WebPage" itemid="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/"/> <header class="post-header"><h1 class="post-title" itemprop="name headline">Static code analysis and compiler warnings</h1><p class="post-meta"><time datetime="2016-05-08T19:00:06+03:00" itemprop="datePublished dateModified">Sunday, May 8, 2016</time> • <span itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"> <span itemprop="name">Jussi Judin</span> </span> • <a itemprop="image" itemscope="itemscope" itemtype="https://schema.org/ImageObject" href="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/id-cropped-800x400.png"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAIAAACr2KkGAAAABnRSTlMAAAAAAABupgeRAAAATUlEQVR4AWOAA76ufjQEl0rWFoEguAg2KcJAv/gNQUTQQaMOohaIP3QagoiRIssdow5CJB2CCJhECCJiHE03B406iOrZHo8UIQeNOggAp69D2pPN4gEAAAAASUVORK5CYII=" title="Article identicon" alt="Article identicon" width="48" height="12"/><meta itemprop="url" content="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/id-cropped-800x400.png"/><meta itemprop="width" content="800"/><meta itemprop="height" content="400"/> </a></p> </header><div class="post-content" itemprop="articleBody"><p>Compiler generated warnings are one form of <a href="https://en.wikipedia.org/wiki/Static_program_analysis">static code analysis</a> that provides a codified form of certain types of beneficial programming practices. Nowadays modern compilers used to compile C family languages (<a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a>, <a href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a>, and <a href="https://en.wikipedia.org/wiki/Objective-C">Objective-C</a>) provide hundreds of different warnings whose usefulness varies depending on project and its aims.</p><p>In this article I will examine what level of issues compiler warnings can find, what is the cost of enabling warnings and analyze compiler warning flag lists for both <a href="http://clang.llvm.org/">clang</a> and <a href="https://gcc.gnu.org/">GCC</a> compilers.</p><h1 id="levels-of-static-code-analysis">Levels of static code analysis</h1><p>Compiling C family languages usually involves preprocessor, compiler, assembler, and a linker. This also leads to situation that static code analysis can be done in various phases of program construction. These generally are:</p><ul><li>Analysis on plain source files.</li><li>Analysis on preprocesses source files.</li><li>Analysis on compilation unit level.</li><li>Link-time analysis.</li></ul><p>This multi-stage program construction results in difficulties for tools that are not called with the exact same arguments providing information about preprocessor definitions, and include and library directories. For example tools like <a href="http://www.splint.org/">splint</a>, <a href="http://cppcheck.sourceforge.net/">Cppcheck</a>, and many editor front-ends work outside the build system and can result in false warnings because they can not see inside some macro definitions that were not included in the simple static analysis setup. This becomes an issue with larger projects that do not necessarily have the most straightforward build setups and the most trivial header file inclusion policies. This does not mean that such tools are useless, but they will result in false positive warnings that can be really annoying unless they are silenced or ignored in some way.</p><p>Analysis on preprocessed source files already provides pretty accurate picture of what kind of issues there can be in the program, but it necessarily is not enough. In the compilation phase compilers constantly transform the program into new, functionally equivalent, forms during optimization phases that can even result in <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">unexpected code removal</a> that is not necessarily trivial to notice. Compilation phase also gives more opportunities for target platform specific static code analysis. For example pipeline stalls or value overflows due to incorrect assumptions on data type sizes can usually be noticed only after the target platform is known.</p><p>Final phase in program construction, that provides options for static analysis, is the linking phase. In the linking phase linker takes care that all the functions and global variables that the program calls come from somewhere and that there are no conflicting duplicate names defined. This should also enable some automatic detection capabilities for memory leaks and such that come from calling functions defined in different compilation units. I’m not sure if any freely available static analyzer does this.</p><h1 id="compiler-warning-flags">Compiler warning flags</h1><p>Compiler warning flags are one way to do static code analysis that cover all possible phases of program construction. This assumes that the compiler is involved in all phases of program construction. And they usually are, as in all phases from preprocessing to linking compiler front-end is used as a wrapper to all the tools that do the actual hard work.</p><h2 id="warning-flags-and-compilation-time">Warning flags and compilation time</h2><p>Using static code analysis in form of compiler warnings incurs some penalty, as they need to execute some extra code in addition to normal code related to compilation. To measure the penalty and to contrast it with some more advanced static analysis tools,</p><p>I did some benchmarks by compiling <a href="http://cppcheck.sourceforge.net/">Cppcheck</a> 1.73 and <a href="http://www.fftw.org/">FFTW</a> 3.3.4 with clang 3.8, GCC 6.1, and Infer 0.8.1 by using <code class="highlighter-rouge">-O3</code> optimization level. Cppcheck is a program mainly written in C++ and FFTW is mainly written in C. Infer has some experimental checks for C++ enabled with <code class="highlighter-rouge">--cxx</code> command line option, so I ran Infer twice for Cppcheck, with and without C++ checks. Clang had all warnings enabled <code class="highlighter-rouge">-Weverything</code> and GCC had all warning options that did not require any special values. This resulted in following minimum execution times of 3 runs:</p><table><thead><tr><th>Compiler</th><th>Program</th><th style="text-align:right">No warnings</th><th style="text-align:right">All warnings</th></tr></thead><tbody><tr><td>clang</td><td>Cppcheck</td><td style="text-align:right">59.3 s</td><td style="text-align:right">1 min 1.1 s (+ 3.0 %)</td></tr><tr><td>GCC</td><td>Cppcheck</td><td style="text-align:right">1 min 32.7 s</td><td style="text-align:right">1 min 38.8 s (+ 6.6 %)</td></tr><tr><td>Infer</td><td>Cppcheck</td><td style="text-align:right">-</td><td style="text-align:right">17 min 50 s (18x slower)</td></tr><tr><td>Infer <code class="highlighter-rouge">--cxx</code></td><td>Cppcheck</td><td style="text-align:right">-</td><td style="text-align:right">1 h 36 min (<strong>97x slower</strong>)</td></tr><tr><td>clang</td><td>FFTW</td><td style="text-align:right">40.5 s</td><td style="text-align:right">40.9 s (+ 1 %)</td></tr><tr><td>GCC</td><td>FFTW</td><td style="text-align:right">42.7 s</td><td style="text-align:right">58.1 s (<strong>+ 36 %</strong>)</td></tr><tr><td>Infer</td><td>FFTW</td><td style="text-align:right">-</td><td style="text-align:right">4 min 43 s (10x slower)</td></tr></tbody></table><p>We can see that for clang and GCC the extra processing time added even by all warnings flags is pretty small compared to all the other compilation and optimization steps for a C++ application (Cppcheck). But for mostly C based application (FFTW) GCC gets surprisingly heavy, although build times still remain within the same order of magnitude.</p><p>If we then compare the time that a more heavy static code analyzer takes, these compiler warnings are extremely cheap way to add static code analysis. They may not catch all the same bugs as these more advanced methods do, but they do offer a cheap way to avoid the basic mistakes.</p><h1 id="warning-flag-lists">Warning flag lists</h1><p>I have created a project that can automatically parse <a href="https://github.com/Barro/compiler-warnings">compiler warning flags from command line option definition files in clang and GCC</a>. This came partially from a necessity and partially from curiosity to examine what kind of options clang and GCC provide in easy to digest format. Although both compiler provide some kind of lists of warning flags as part of their documentation, they are pretty cumbersome to go through when the main interest is first figure what there is available and then just look at the details.</p><h2 id="warning-options-and-deprecation">Warning options and deprecation</h2><p>Different compilers have different policies about backwards compatibility and deprecation. When looking at how warning options have evolved, GCC has not removed between versions 3.4 and 6.1 a single switch, it has just switched them to do nothing (<code class="highlighter-rouge">-Wimport</code>, <code class="highlighter-rouge">-Wunreachable-code</code>, and <code class="highlighter-rouge">-Wmudflap</code> switches). Clang on the other hand has removed multiple switches between versions and for example there is no references to <code class="highlighter-rouge">-Wcxx98-cxx11-compat</code> in the current codebase even if clang 3.3 had such switch.</p><h2 id="examining-differences-visually">Examining differences visually</h2><p>Generating large purely textual differences between different files becomes quite cumbersome quite soon if you want to do anything more complicated than a simple difference of unique command line options between two subsequent versions. For example if we look at <a href="#figure-gcc-5-6-wall">figure 1</a> that shows what other warnings <code class="highlighter-rouge">-Wall</code> flag enables in GCC 6 when compared to GCC 5. We can see that there are quite many extra warnings added to <code class="highlighter-rouge">-Wall</code> switch so newer compiler versions provide extra analysis capabilities even without adding all the new options individually.</p><div class="text-center"> <figure class="inline-figure" id="figure-gcc-5-6-wall"> <a href="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-wall.png"> <picture><source type="image/webp" srcset="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-wall.webp 887w" sizes="887px"/> <source type="image/png" srcset="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-wall.png 887w" sizes="887px"/><img src="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-wall.png" alt="Meld showing differences what flags
-Wall enables between GCC 5 and 6." title="Meld showing differences what flags -Wall enables between GCC 5 and 6." width="700" height="469" class="figure-image"/> </picture> </a> <figcaption><p>Figure 1: <a href="http://meldmerge.org/">Meld</a> showing differences what flags <code class="highlighter-rouge">-Wall</code> enables between GCC 5 and 6.</p> </figcaption> </figure></div><p>From <a href="#figure-gcc-5-6-cxx-compat">figure 2</a> we can also see that GCC 6 uses <code class="highlighter-rouge">-Wc++11-compat</code> as the default warning flag indicating differences between ISO C++ 1998 and ISO C++ 2011 for constructs that have the same name instead of <code class="highlighter-rouge">-Wc++0x-compat</code>, that refers to a draft standard. So GCC has basically deprecated <code class="highlighter-rouge">-Wc++0x-compat</code> switch in favor of a switch that refers to the actual standard.</p><div class="text-center"> <figure class="inline-figure" id="figure-gcc-5-6-cxx-compat"> <a href="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-cxx-compat.png"><picture><source type="image/webp" srcset="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-cxx-compat.webp 887w" sizes="887px"/> <source type="image/png" srcset="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-cxx-compat.png 887w" sizes="887px"/><img src="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/meld-gcc-5-6-cxx-compat.png" alt="-Wc++0x-compat is an alias of -Wc++11-compat in GCC 6 instead the other way around." title="-Wc++0x-compat is an alias of -Wc++11-compat in GCC 6 instead the other way around." width="700" height="99" class="figure-image"/></picture> </a> <figcaption><p>Figure 2: <code class="highlighter-rouge">-Wc++0x-compat</code> is an alias of <code class="highlighter-rouge">-Wc++11-compat</code> in GCC 6 instead the other way around.</p> </figcaption> </figure></div><h1 id="suggestions-for-usable-warning-options">Suggestions for usable warning options</h1><p>I won’t be giving any specific suggestions here for warning flags, as there seem to be new options for each subsequent compiler release. A good place to start is <a href="https://www.nasa.gov/">NASA</a>’s <a href="http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf">JPL Institutional Coding Standard for the C Programming Language</a> that includes a very short list of rudimentary warning flags for GCC. It also includes a short list of coding standards of which <a href="https://vimeo.com/84991949">each one would have prevented a mission failure</a> for NASA. <a href="https://www.securecoding.cert.org/">SEI CERT coding standards</a> for secure coding also provide various automatically generated lists for <a href="https://www.securecoding.cert.org/confluence/display/cplusplus/Clang">clang warning flags</a> and <a href="https://www.securecoding.cert.org/confluence/display/cplusplus/GCC">GCC warning flags</a> based on the issues that these standards take into account.</p><p>And finally, check out the <a href="https://github.com/Barro/compiler-warnings">warning flag lists for clang and GCC</a> and make your own combinations that bring the most benefit for whatever you are working with. Not all of them are appropriate for your project and some of them may be even working against the useful development patterns that you have.</p><h2 id="cautionary-tales-about-compiler-warnings-flags">Cautionary tales about compiler warnings flags</h2><p>Even though it might sound like a good idea to rush and fix all the issues that these new compiler warning flags uncover, it might actually cause some new bugs to pop up. Specifically <a href="https://www.sqlite.org/">SQLite</a> database engine has had its own take on <a href="https://www.sqlite.org/testing.html#staticanalysis">compiler warnings and their fixing</a> and they have concluded that fixing compiler warnings actually has produced some extra bugs that would not have come into light if there would have not been tries to fix compiler warnings.</p><p>I have also had my own take on compiler warning fixes and sometimes I have screwed up and messed up with a perfectly working code while fixing a misleading warning. But generally my own experience has lead to more fixes than what there have been bugs. And the coolest thing is, that having these warnings enabled as the standard development process prevent some bugs from ever creeping up to the application in the first place.</p></div></article><div id="disqus_thread"></div> <script>var disqus_config=function(){this.page.url="https://barro.github.io/2016/05/static-code-analysis-and-compiler-warnings/",this.page.identifier="/2016/05/static-code-analysis-and-compiler-warnings"};!function(){var i=document,t=i.createElement("script");t.src="//barro.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(i.head||i.body).appendChild(t)}()</script></div></div><footer class="site-footer"><div class="wrapper"><h2 class="footer-heading">Jussi Judin's weblog</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li>Jussi Judin</li><li>jju<span>din</span>+github <span>AT</span> iki DOT <span>f</span>i</li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li> <a href="https://github.com/barro" title="Barro">GitHub</a></li><li> <a href="https://bitbucket.org/barro" title="barro">Bitbucket</a></li><li> <a href="https://facebook.com/b4rr0" title="B4rr0">Facebook</a></li><li> <a href="https://twitter.com/B4rr0" title="@B4rr0">Twitter</a></li><li> <a href="https://plus.google.com/+JussiJudin-jj/" title="+JussiJudin-jj">Google+</a></li></ul></div><div class="footer-col footer-col-3"><p>Programming related topics. Maybe even some original content!</p></div></div></div></footer><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-71880517-1","auto"),ga("send","pageview")</script></body></html>